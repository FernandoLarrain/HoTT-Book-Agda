{-# OPTIONS --without-K --exact-split --safe #-}

open import Ch1.Type-theory
open import Ch2.Homotopy-type-theory
open import Ch3.Sets-and-logic
open import Ch4.Equivalences
open import Ch5.8-Id-types-and-id-systems

module int-as-HIT.thesis where


-- I. ℕ- and ℤ-Algebras

ℕAlg : (𝓤 : Universe) → 𝓤 ⁺ ̇
ℕAlg 𝓤 = Σ A ꞉ (𝓤 ̇) , A × (A → A)

ℤAlg : (𝓤 : Universe) → 𝓤 ⁺ ̇
ℤAlg 𝓤 = Σ A ꞉ (𝓤 ̇) , A × (Σ s ꞉ (A → A) , ishae s)

{- Notation:

ℤAlg 𝓤 = Σ A ꞉ (𝓤 ̇) ,
         Σ a₀ ꞉ A ,
         Σ s ꞉ (A → A) ,
         Σ p ꞉ (A → A) ,
         Σ σ ꞉ (p ∘ s ∼ id) ,
         Σ ρ ꞉ (s ∘ p ∼ id) ,
         ((a : A) → ap s (σ a) ≡ ρ (s a)) -- τ

-}


-- II. ℕ- and ℤ-Algebra Homomorphisms

-- Equivalences as objects

Eqv : (𝓤 : Universe) → 𝓤 ⁺ ̇
Eqv 𝓤 = Σ A₁ ꞉ (𝓤 ̇) , Σ A₂ ꞉ (𝓤 ̇) , A₁ ≃ A₂

-- Equivalence-preserving maps

module EqvPreservation {A₁ A₂ : 𝓤 ̇} {B₁ B₂ : 𝓥 ̇} (f₁ : A₁ → B₁) (f₂ : A₂ → B₂) where

  module MapPreservation where

    s-pres : (A₁ → A₂) → (B₁ → B₂) → 𝓤 ⊔ 𝓥 ̇
    s-pres s s' = f₂ ∘ s ∼ s' ∘ f₁

    p-pres : (A₂ → A₁) → (B₂ → B₁) → 𝓤 ⊔ 𝓥 ̇
    p-pres p p' = f₁ ∘ p ∼ p' ∘ f₂

  open MapPreservation public

  module HtpyPreservation (s : A₁ → A₂) (p : A₂ → A₁) (s' : B₁ → B₂) (p' : B₂ → B₁) (α : s-pres s s') (β : p-pres p p') where

    aux-γ : f₁ ∘ p ∘ s ∼ p' ∘ s' ∘ f₁
    aux-γ a₁ = β (s a₁) ∙ ap p' (α a₁)

    σ-pres : (p ∘ s ∼ id) → (p' ∘ s' ∼ id) → 𝓤 ⊔ 𝓥 ̇
    σ-pres σ σ' = (a₁ : A₁) → ap f₁ (σ a₁) ≡ aux-γ a₁ ∙ σ' (f₁ a₁)

    aux-δ : f₂ ∘ s ∘ p ∼ s' ∘ p' ∘ f₂
    aux-δ a₂ = α (p a₂) ∙ ap s' (β a₂)

    ρ-pres : (s ∘ p ∼ id) → (s' ∘ p' ∼ id) → 𝓤 ⊔ 𝓥 ̇
    ρ-pres ρ ρ' = (a₂ : A₂) → ap f₂ (ρ a₂) ≡ aux-δ a₂ ∙ ρ' (f₂ a₂)

  module CohPreservation (s : A₁ → A₂) (p : A₂ → A₁) (s' : B₁ → B₂) (p' : B₂ → B₁) (α : s-pres s s') (β : p-pres p p') where

    open HtpyPreservation s p s' p' α β

    aux-ε-γ₁ : f₂ ∘ s ∘ p ∘ s ∼ s' ∘ p' ∘ s' ∘ f₁
    aux-ε-γ₁ a₁ = α (p (s a₁)) ∙ ap s' (aux-γ a₁)

    aux-ε-δ₁ : f₂ ∘ s ∘ p ∘ s ∼ s' ∘ p' ∘ s' ∘ f₁
    aux-ε-δ₁ a₁ = aux-δ (s a₁) ∙ ap s' (ap p' (α a₁))

    aux-ε-γ₁-is-aux-ε-δ₁ : aux-ε-γ₁ ∼ aux-ε-δ₁
    aux-ε-γ₁-is-aux-ε-δ₁ a₁ = (refl (α (p (s a₁))) ✦ ap-∙ s' _ _) ∙ ∙-assoc _ _ _

    aux-ε-γ₂ : (σ : p ∘ s ∼ id) (σ' : p' ∘ s' ∼ id) → ((a₁ : A₁) → ap f₁ (σ a₁) ≡ aux-γ a₁ ∙ σ' (f₁ a₁)) → (a₁ : A₁) → ap f₂ (ap s (σ a₁)) ∙ α a₁ ≡ aux-ε-γ₁ a₁ ∙ ap s' (σ' (f₁ a₁))
    aux-ε-γ₂ σ σ' γ a₁ = (ap-∘ s f₂ (σ a₁) ✦ refl (α a₁)) ∙ hnat α (σ a₁) ⁻¹ ∙ (refl (α (p (s a₁))) ✦ (ap-∘ f₁ s' (σ a₁) ⁻¹ ∙ ap (ap s') (γ a₁) ∙ ap-∙ s' _ _)) ∙ ∙-assoc _ _ _

    aux-ε-δ₂ : (ρ : s ∘ p ∼ id) (ρ' : s' ∘ p' ∼ id) → ((a₂ : A₂) → ap f₂ (ρ a₂) ≡ aux-δ a₂ ∙ ρ' (f₂ a₂)) → (a₁ : A₁) → ap f₂ (ρ (s a₁)) ∙ α a₁ ≡ aux-ε-δ₁ a₁ ∙ ρ' (s' (f₁ a₁))
    aux-ε-δ₂ ρ ρ' δ a₁ = (δ (s a₁) ✦ ap-id (α a₁) ⁻¹) ∙ ∙-assoc _ _ _ ⁻¹ ∙ (refl (aux-δ (s a₁)) ✦ (hnat ρ' (α a₁) ∙ (ap-∘ p' s' (α a₁) ⁻¹ ✦ refl (ρ' (s' (f₁ a₁)))))) ∙ ∙-assoc _ _ _

    τ-pres : (σ : p ∘ s ∼ id) (ρ : s ∘ p ∼ id) (τ : (a₁ : A₁) → ap s (σ a₁) ≡ ρ (s a₁)) (σ' : p' ∘ s' ∼ id) (ρ' : s' ∘ p' ∼ id) (τ' : (b₁ : B₁) → ap s' (σ' b₁) ≡ ρ' (s' b₁)) (γ : σ-pres σ σ') (δ : ρ-pres ρ ρ') → 𝓤 ⊔ 𝓥 ̇
    τ-pres σ ρ τ σ' ρ' τ' γ δ = (a₁ : A₁) → (ap (ap f₂) (τ a₁) ✦ refl (α a₁)) ∙ aux-ε-δ₂ ρ ρ' δ a₁ ≡ aux-ε-γ₂ σ σ' γ a₁ ∙ (aux-ε-γ₁-is-aux-ε-δ₁ a₁ ✦ τ' (f₁ a₁))

hae-pres : (A : Eqv 𝓤) (B : Eqv 𝓥) → (pr₁ A → pr₁ B) → (pr₁ (pr₂ A) → pr₁ (pr₂ B)) → 𝓤 ⊔ 𝓥 ̇
hae-pres (A₁ , A₂ , s , p , σ , ρ , τ) (B₁ , B₂ , s' , p' , σ' , ρ' , τ') f₁ f₂ =
  Σ α ꞉ s-pres s s' ,
  Σ β ꞉ p-pres p p' ,
  Σ γ ꞉ σ-pres α β σ σ' ,
  Σ δ ꞉ ρ-pres α β ρ ρ' ,
  τ-pres α β σ ρ τ σ' ρ' τ' γ δ
  where open EqvPreservation f₁ f₂
        open HtpyPreservation s p s' p'
        open CohPreservation s p s' p'

hae-semipres : (A : Eqv 𝓤) (B : Eqv 𝓥) (f₁ : pr₁ A → pr₁ B) (f₂ : pr₁ (pr₂ A) → pr₁ (pr₂ B)) → EqvPreservation.s-pres f₁ f₂ (pr₁ (pr₂ (pr₂ A))) (pr₁ (pr₂ (pr₂ B))) → 𝓤 ⊔ 𝓥 ̇
hae-semipres (A₁ , A₂ , s , p , σ , ρ , τ) (B₁ , B₂ , s' , p' , σ' , ρ' , τ') f₁ f₂ α =
  Σ β ꞉ p-pres p p' ,
  Σ γ ꞉ σ-pres β σ σ' ,
  Σ δ ꞉ ρ-pres β ρ ρ' ,
  τ-pres β σ ρ τ σ' ρ' τ' γ δ
  where open EqvPreservation f₁ f₂
        open HtpyPreservation s p s' p' α
        open CohPreservation s p s' p' α

EqvHom : Eqv 𝓤 → Eqv 𝓥 → 𝓤 ⊔ 𝓥 ̇
EqvHom A B = Σ f₁ ꞉ (pr₁ A → pr₁ B) , Σ f₂ ꞉ (pr₁ (pr₂ A) → pr₁ (pr₂ B)) , hae-pres A B f₁ f₂

-- Simple equivalence-preserving maps

module SimpleHom ⦃ fe : FunExt ⦄ (A : 𝓤 ̇) (B : 𝓥 ̇) (f : A → B) where

  open EqvPreservation f f
  open HtpyPreservation id id id id
  open CohPreservation id id id id

  abstract
  
    lemma-1 : isContr (Σ β ꞉ p-pres id id , σ-pres (hrefl _) β (hrefl _) (hrefl _))
    lemma-1 = ≃-preserves-Contr
      (split , (dep-Σ-UMP A (λ a → f a ≡ f a) λ a βa → refl (f a) ≡ (βa ∙ refl (f a)) ∙ refl (f a)))
      (Π-preserves-Contr _ (λ a → ≃-preserves-Contr (Σ-preserves-family-≃ (λ βa → post-∙-≃ (refl (f a)) (ru βa ∙ ru _))) (free-right-endpt-is-Contr _ _)))

    lemma-2 : isContr (Σ δ ꞉ ρ-pres (hrefl _) (hrefl _) (hrefl _) (hrefl _) , τ-pres (hrefl _) (hrefl _) (hrefl _) (hrefl _) (hrefl _) (hrefl _) (hrefl _) (hrefl _) (hrefl _) δ)
    lemma-2 = ≃-preserves-Contr
      (split , (dep-Σ-UMP A (λ a → refl (f a) ≡ refl _ ∙ refl _ ∙ refl _) λ a δa → refl _ ∙ (refl _ ∙ δa ∙ refl _ ∙ refl _ ∙ refl _ ∙ refl _ ∙ refl _) ≡ refl (refl (f a))))
      (Π-preserves-Contr _ (λ a → ≃-preserves-Contr (Σ-preserves-family-≃ (λ δa → pre-∙-≃ (refl (refl (f a))) (lu _ ⁻¹ ∙ ru _ ⁻¹ ∙ ru _ ⁻¹ ∙ ru _ ⁻¹ ∙ ru _ ⁻¹ ∙ ru _ ⁻¹ ∙ lu δa ⁻¹))) (free-left-endpt-is-Contr _ _)))

    Contr-lemma : isContr (hae-semipres (A , A , ≃-refl A) (B , B , ≃-refl B) f f (hrefl _))
    Contr-lemma = ≃-preserves-Contr (≃-sym (Σ-assoc _ _ _ ● Σ-over-Contr-base-is-fib _ _ lemma-1)) lemma-2

-- The corresponding forgetful functor is fully-faithful.

simple-homs : ⦃ fe : FunExt ⦄ ⦃ univ : Univalence ⦄ (A₁ A₂ : 𝓤 ̇) (e : A₁ ≃ A₂) (B₁ B₂ : 𝓥 ̇) (e' : B₁ ≃ B₂) (f₁ : A₁ → B₁) (f₂ : A₂ → B₂) → hae-pres (A₁ , A₂ , e) (B₁ , B₂ , e') f₁ f₂ ≃ (f₂ ∘ pr₁ e ∼ pr₁ e' ∘ f₁)
simple-homs {𝓤} {𝓥} = 𝕁-≃ (λ A₁ A₂ e → (B₁ B₂ : 𝓥 ̇) (e' : B₁ ≃ B₂) (f₁ : A₁ → B₁) (f₂ : A₂ → B₂) → hae-pres (A₁ , A₂ , e) (B₁ , B₂ , e') f₁ f₂ ≃ (f₂ ∘ pr₁ e ∼ pr₁ e' ∘ f₁)) λ A →
  𝕁-≃ (λ B₁ B₂ e' → (f₁ : A → B₁) (f₂ : A → B₂) → hae-pres (A , A , ≃-refl A) (B₁ , B₂ , e') f₁ f₂ ≃ (f₂ ∘ id ∼ pr₁ e' ∘ f₁))
  λ B f₁ f₂ →
    Σ-of-Contr-family-is-base _ _ (𝕁-∼ (λ f₂ f₁ α → isContr (hae-semipres (A , A , ≃-refl A) (B , B , ≃-refl B) f₁ f₂ α)) (SimpleHom.Contr-lemma A B) f₂ f₁)

-- ℕ- and ℤ-Algebra homomorphisms

ℕHom : ℕAlg 𝓤 → ℕAlg 𝓥 → 𝓤 ⊔ 𝓥 ̇
ℕHom (A , a₀ , s) (B , b₀ , s') = Σ f ꞉ (A → B) , (f a₀ ≡ b₀) × (f ∘ s ∼ s' ∘ f)

ℤHom : ℤAlg 𝓤 → ℤAlg 𝓥 → 𝓤 ⊔ 𝓥 ̇
ℤHom (A , a₀ , s , s-is-hae) (B , b₀ , s' , s'-is-hae) = Σ f ꞉ (A → B) , (f a₀ ≡ b₀) × hae-pres (A , A , s , s-is-hae) (B , B , s' , s'-is-hae) f f

ℕcomp : (A : ℕAlg 𝓤) (B : ℕAlg 𝓥) (C : ℕAlg 𝓦) → ℕHom B C → ℕHom A B → ℕHom A C
ℕcomp (A , a₀ , s) (B , b₀ , t)  (C , c₀ , u) (g , q' , α') (f , q , α) = g ∘ f , (ap g q ∙ q') , λ a → ap g (α a) ∙ α' (f a) 

ℕid : (A : ℕAlg 𝓤) → ℕHom A A
ℕid A = id , refl _ , hrefl _
 
-- Identity type of ℕ-Algebra homomorphisms

ℕHomId : (A : ℕAlg 𝓤) (B : ℕAlg 𝓥) → ℕHom A B → ℕHom A B → 𝓤 ⊔ 𝓥 ̇
ℕHomId (A , a₀ , s) (B , b₀ , t) (f , q , α) (g , q' , α') = Σ H ꞉ (f ∼ g) , (q ≡ H a₀ ∙ q') × ((a : A) → α a ∙ ap t (H a) ≡ H (s a) ∙ α' a)

ℕHom-≡-elim : (A : ℕAlg 𝓤) (B : ℕAlg 𝓥) (f g : ℕHom A B) → f ≡ g → ℕHomId A B f g
ℕHom-≡-elim A B f .f (refl .f) = hrefl _ , lu _ , λ a → ru _ ⁻¹ ∙ lu _ 

ΣℕHomId-is-Contr : ⦃ fe : FunExt ⦄ (A : ℕAlg 𝓤) (B : ℕAlg 𝓥) (f : ℕHom A B) → isContr (Σ g ꞉ ℕHom A B , ℕHomId A B f g)
ΣℕHomId-is-Contr (A , a₀ , s) (B , b₀ , t) (f , q , α) = ≃-preserves-Contr (≃-sym (Σ-over-Contr-base-is-fib _ _ (≃-preserves-Contr (Σ-preserves-family-≃ (λ g → happly , happly-is-equiv)) (free-right-endpt-is-Contr _ _ ))) ● aux-equiv) (×-preserves-Contr _ _ {!!} {!!}) where
  aux-to : (Σ w ꞉ (Σ g ꞉ (A → B) , (f ∼ g)) , (Σ q' ꞉ (pr₁ w a₀ ≡ b₀) , (q ≡ pr₂ w a₀ ∙ q')) × (Σ α' ꞉ (pr₁ w ∘ s ∼ t ∘ pr₁ w) , ((a : A) → α a ∙ ap t (pr₂ w a) ≡ pr₂ w (s a) ∙ α' a))) → (Σ g ꞉ ℕHom (A , a₀ , s) (B , b₀ , t) , ℕHomId (A , a₀ , s) (B , b₀ , t) (f , q , α) g)
  aux-to ((g , H) , (q' , r) , (α' , ξ)) = ((g , q' , α') , (H , r , ξ))
  aux-from : (Σ g ꞉ ℕHom (A , a₀ , s) (B , b₀ , t) , ℕHomId (A , a₀ , s) (B , b₀ , t) (f , q , α) g) → (Σ w ꞉ (Σ g ꞉ (A → B) , (f ∼ g)) , (Σ q' ꞉ (pr₁ w a₀ ≡ b₀) , (q ≡ pr₂ w a₀ ∙ q')) × (Σ α' ꞉ (pr₁ w ∘ s ∼ t ∘ pr₁ w) , ((a : A) → α a ∙ ap t (pr₂ w a) ≡ pr₂ w (s a) ∙ α' a)))
  aux-from ((g , q' , α') , (H , r , ξ)) = ((g , H) , (q' , r) , (α' , ξ))
  aux-to∘from : aux-to ∘ aux-from ∼ id
  aux-to∘from ((g , q' , α') , (H , r , ξ)) = refl _
  aux-from∘to : aux-from ∘ aux-to ∼ id
  aux-from∘to ((g , H) , (q' , r) , (α' , ξ)) = refl _
  aux-equiv : (Σ w ꞉ (Σ g ꞉ (A → B) , (f ∼ g)) , (Σ q' ꞉ (pr₁ w a₀ ≡ b₀) , (q ≡ pr₂ w a₀ ∙ q')) × (Σ α' ꞉ (pr₁ w ∘ s ∼ t ∘ pr₁ w) , ((a : A) → α a ∙ ap t (pr₂ w a) ≡ pr₂ w (s a) ∙ α' a))) ≃ (Σ g ꞉ ℕHom (A , a₀ , s) (B , b₀ , t) , ℕHomId (A , a₀ , s) (B , b₀ , t) (f , q , α) g)
  aux-equiv = aux-to , qinv-to-isequiv (aux-from , aux-to∘from , aux-from∘to)


-- III. Forgetful Functor

U₀ : ℤAlg 𝓤 → ℕAlg 𝓤
U₀ (A , a₀ , s , s-is-hae) = (A , a₀ , s)

U₁ : (A : ℤAlg 𝓤) (B : ℤAlg 𝓥) → ℤHom A B → ℕHom (U₀ A) (U₀ B)
U₁ A B (f , q , α , etc) = f , q , α

-- U is injective on objects

-- U₀-is-inj : (A : ℤAlg 𝓤) (B : ℤAlg 𝓥) → U₀ A ≡ U₀ B ≃ A ≡ B
-- U₀-is-inj = ?

-- U is Fully Faithful

U-is-FF : ⦃ fe : FunExt ⦄ ⦃ univ : Univalence ⦄ (A : ℤAlg 𝓤) (B : ℤAlg 𝓥) → ℤHom A B ≃ ℕHom (U₀ A) (U₀ B)
U-is-FF (A , a₀ , s , s-is-hae) (B , b₀ , s' , s'-is-hae) = Σ-assoc _ _ _ ● Σ-preserves-family-≃ (Σ-induction (λ f q → simple-homs A A (s , s-is-hae) B B (s' , s'-is-hae) f f)) ● ≃-sym (Σ-assoc _ _ _)



-- IV. Fibered ℕ- and ℤ-Algebras

FibℕAlg : (𝓥 : Universe) → ℕAlg 𝓤 → 𝓤 ⊔ (𝓥 ⁺) ̇
FibℕAlg 𝓥 (A , a₀ , s) = Σ E ꞉ (A → 𝓥 ̇) , E a₀ × ((a : A) → E a → E (s a))





