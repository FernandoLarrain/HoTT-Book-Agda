{-# OPTIONS --without-K --exact-split --safe #-}

module Ch2.13-Natural-numbers where

open import Ch1.Type-theory
open import Ch2.1-Types-are-higher-groupoids
open import Ch2.2-Functions-are-functors
open import Ch2.3-Type-families-are-fibrations
open import Ch2.4-Homotopies-and-equivalences
open import Ch2.8-The-unit-type
open import Ch2.11-Identity-type


-- Theorem 2.13.1 (Path-space of â„•).

-- (i) Setting up encode-decode

code-â„• : â„• â†’ â„• â†’ ğ“¤â‚€ Ì‡
code-â„• 0 0 = ğŸ™
code-â„• (succ m) 0 = ğŸ˜
code-â„• 0 (succ n) = ğŸ˜
code-â„• (succ m) (succ n) = code-â„• m n

rcode : (n : â„•) â†’ code-â„• n n
rcode 0 = â‹†
rcode (succ n) = rcode n

encode-â„• : (m n : â„•) â†’ m â‰¡ n â†’ code-â„• m n
encode-â„• m n p = transport (code-â„• m) p (rcode m)

decode-â„• : (m n : â„•) â†’ (code-â„• m n) â†’ m â‰¡ n
decode-â„• 0 0 = ğŸ™-recursion (0 â‰¡ 0) (refl 0)
decode-â„• (succ m) 0 = !ğŸ˜ _
decode-â„• 0 (succ n) = !ğŸ˜ _
decode-â„• (succ m) (succ n) = (ap succ) âˆ˜ (decode-â„• m n)

-- (ii) Characterization of path space of â„•

path-space-â„•' : (m n : â„•) â†’ (encode-â„• m n âˆ˜ decode-â„• m n) âˆ¼ id
path-space-â„•' zero zero c = ğŸ™-is-Prop _ _
path-space-â„•' (succ m) zero = ğŸ˜-induction _
path-space-â„•' zero (succ n) = ğŸ˜-induction _
path-space-â„•' (succ m) (succ n) c =
 transport (code-â„• (succ m)) (ap succ (decode-â„• m n c)) (rcode m) â‰¡âŸ¨ ( transport-âˆ˜ (code-â„• (succ m)) succ (decode-â„• m n c) (rcode m) ) â»Â¹ âŸ© (
 transport ((code-â„• (succ m)) âˆ˜ succ) (decode-â„• m n c) (rcode m) â‰¡âŸ¨ refl _ âŸ© (
 encode-â„• m n (decode-â„• m n c) â‰¡âŸ¨ path-space-â„•' m n c âŸ© (
 c âˆ)))

path-space-â„•'' : (m n : â„•) â†’ (decode-â„• m n âˆ˜ encode-â„• m n) âˆ¼ id
path-space-â„•'' zero .0 (refl .0) = refl _
path-space-â„•'' (succ m) .(succ m) (refl .(succ m)) = ap (ap succ) (path-space-â„•'' m m (refl m))

path-space-â„• : (m n : â„•) â†’ (m â‰¡ n) â‰ƒ code-â„• m n
path-space-â„• m n = encode-â„• m n , qinv-to-isequiv ((decode-â„• m n) , ((path-space-â„•' m n) , (path-space-â„•'' m n)))


-- Corollaries

succ-is-not-0 : (n : â„•) â†’ Â¬ (succ n â‰¡ 0)
succ-is-not-0 n = encode-â„• (succ n) 0

succ-is-injective : (m n : â„•) â†’ succ m â‰¡ succ n â†’ m â‰¡ n
succ-is-injective m n = decode-â„• m n âˆ˜ encode-â„• (succ m) (succ n)


-- Remarks (used to prove that â„• is a set in 1-Sets-and-n-types)

code-â„•-is-ğŸ˜-or-ğŸ™ : (m n : â„•) â†’ ((code-â„• m n â‰¡ ğŸ˜) + (code-â„• m n â‰¡ ğŸ™))
code-â„•-is-ğŸ˜-or-ğŸ™ zero zero = inr (refl _)
code-â„•-is-ğŸ˜-or-ğŸ™ zero (succ n) = inl (refl _)
code-â„•-is-ğŸ˜-or-ğŸ™ (succ m) zero = inl (refl _)
code-â„•-is-ğŸ˜-or-ğŸ™ (succ m) (succ n) = +-recursion inl inr (code-â„•-is-ğŸ˜-or-ğŸ™ m n)

code-â„•-is-Prop : (m n : â„•) (x y : code-â„• m n) â†’ x â‰¡ y
code-â„•-is-Prop m n = +-recursion
 (Î» p â†’ transport P (p â»Â¹) (ğŸ˜-induction (Î» x â†’ (y : ğŸ˜) â†’ x â‰¡ y)))
 (Î» p â†’ transport P (p â»Â¹) (ğŸ™-is-Prop))
 (code-â„•-is-ğŸ˜-or-ğŸ™ m n)
 where
 P : ğ“¤â‚€ Ì‡  â†’ ğ“¤â‚€ Ì‡
 P = Î» t â†’ (x y : t) â†’ x â‰¡ y
